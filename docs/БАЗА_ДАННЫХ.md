# Как работает база данных и подключение

## Архитектура подключения

Проект использует **трехзвенную архитектуру** для работы с базой данных:

```
Веб-интерфейс (Vue.js)
        ↓ HTTP запросы
Flask приложение (app.py)
        ↓ SQL запросы
Модуль database.py
        ↓ psycopg2
PostgreSQL база данных
```

## 1. Конфигурация подключения

### Файл `.env`
Параметры подключения хранятся в файле `.env` в корне проекта:

```env
DB_HOST=localhost
DB_PORT=5432
DB_NAME=insects_db
DB_USER=wedben
DB_PASSWORD=
```

### Файл `config.py`
Модуль `config.py` загружает переменные окружения и создает словарь конфигурации:

```python
from dotenv import load_dotenv
import os

load_dotenv()  # Загружает .env файл

DB_CONFIG = {
    'host': os.getenv('DB_HOST', 'localhost'),
    'port': os.getenv('DB_PORT', '5432'),
    'database': os.getenv('DB_NAME', 'insects_db'),
    'user': os.getenv('DB_USER', 'postgres'),
    'password': os.getenv('DB_PASSWORD', '')
}
```

**Важно:** Если файл `.env` отсутствует, используются значения по умолчанию.

## 2. Класс Database

### Инициализация
В `app.py` создается единственный экземпляр класса `Database`:

```python
from database import Database

app = Flask(__name__)
db = Database()  # Создается один раз при запуске приложения
```

### Метод `get_connection()`
Создает новое подключение к PostgreSQL при каждом вызове:

```python
def get_connection(self):
    """Получить подключение к PostgreSQL"""
    return psycopg2.connect(
        host=self.config['host'],
        port=self.config['port'],
        database=self.config['database'],
        user=self.config['user'],
        password=self.config['password']
    )
```

**Особенности:**
- Использует библиотеку `psycopg2` - официальный адаптер PostgreSQL для Python
- Подключение создается для каждого запроса (не пул соединений)
- После использования подключение нужно закрывать

## 3. Работа с запросами

### Пример: метод `search_insects()`

```python
def search_insects(self, insect_type: str, params: Dict) -> List[Dict]:
    # 1. Определяем имя таблицы
    table_names = {
        'dragonfly': 'dragonflies',
        'beetle': 'beetles',
        'butterfly': 'butterflies'
    }
    table_name = table_names.get(insect_type)
    
    # 2. Создаем подключение
    conn = self.get_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    # 3. Формируем SQL запрос динамически
    query = f"SELECT * FROM {table_name} WHERE 1=1"
    conditions = []
    values = []
    
    # Добавляем условия поиска
    if params.get('size_min'):
        conditions.append("size_min >= %s")
        values.append(params['size_min'])
    
    # ... другие условия ...
    
    # 4. Выполняем запрос
    if conditions:
        query += " AND " + " AND ".join(conditions)
    
    cursor.execute(query, values)
    results = cursor.fetchall()
    
    # 5. Закрываем подключение
    cursor.close()
    conn.close()
    
    # 6. Возвращаем результаты
    return [dict(row) for row in results]
```

### Безопасность запросов

**Параметризованные запросы** защищают от SQL-инъекций:

```python
# ✅ ПРАВИЛЬНО - параметризованный запрос
cursor.execute("SELECT * FROM dragonflies WHERE size_min >= %s", [size_value])

# ❌ НЕПРАВИЛЬНО - уязвимо к SQL-инъекциям
cursor.execute(f"SELECT * FROM dragonflies WHERE size_min >= {size_value}")
```

### RealDictCursor

Используется `RealDictCursor` для получения результатов в виде словарей:

```python
from psycopg2.extras import RealDictCursor

cursor = conn.cursor(cursor_factory=RealDictCursor)
# Результаты: [{'id': 1, 'name_ru': 'Стрекоза', ...}, ...]
# Вместо: [(1, 'Стрекоза', ...), ...]
```

## 4. Структура базы данных

### Основные таблицы видов насекомых:

1. **dragonflies** (54 записи)
   - Хранит информацию о стрекозах
   - Поля: id, name_ru, name_lat, size_min, size_max, color, habitat, season, description

2. **beetles** (35 записей)
   - Хранит информацию о жуках
   - Аналогичная структура

3. **butterflies** (25 записей)
   - Хранит информацию о бабочках
   - Аналогичная структура

### Таблицы системы наблюдений:

4. **Пользователь** - пользователи системы
5. **МестоНаблюдения** - географические точки
6. **ВидНасекомого** - объединенная таблица всех видов
7. **Биотоп** (7 записей) - типы биотопов
8. **СтатусТочности** (4 записи) - статусы идентификации
9. **Наблюдение** - записи наблюдений
10. **Идентификация** - связь наблюдений с видами
11. **ВидНасекомого_Биотоп** - связь многие-ко-многим

## 5. API Endpoints и работа с БД

### POST /api/search
```python
@app.route('/api/search', methods=['POST'])
def search_insects():
    data = request.json
    insect_type = data.get('type')
    params = data.get('params', {})
    
    # Вызов метода поиска в БД
    results = db.search_insects(insect_type, params)
    
    return jsonify({
        'success': True,
        'count': len(results),
        'results': results
    })
```

**Поток данных:**
1. Клиент отправляет POST запрос с параметрами поиска
2. Flask получает JSON данные
3. Вызывается `db.search_insects()` - создается подключение к БД
4. Выполняется SQL запрос с параметрами
5. Результаты преобразуются в JSON
6. Ответ отправляется клиенту

### GET /api/all/<insect_type>
```python
@app.route('/api/all/<insect_type>', methods=['GET'])
def get_all_insects(insect_type):
    results = db.get_all_insects(insect_type)
    return jsonify({
        'success': True,
        'count': len(results),
        'results': results
    })
```

### GET /api/filter-options/<insect_type>
```python
@app.route('/api/filter-options/<insect_type>', methods=['GET'])
def get_filter_options(insect_type):
    options = db.get_filter_options(insect_type)
    return jsonify({
        'success': True,
        'options': options
    })
```

## 6. Особенности работы с данными

### Динамическое извлечение опций фильтров

Метод `get_filter_options()` анализирует данные в БД и извлекает уникальные значения:

```python
def get_filter_options(self, insect_type: str) -> Dict:
    # 1. Получаем все описания из таблицы
    cursor.execute(f"SELECT description FROM {table_name}")
    
    # 2. Используем регулярные выражения для извлечения значений
    # Например, для цвета глаз:
    matches = re.findall(r'Цвет глаз:\s*([^;]+)', description)
    
    # 3. Очищаем и категоризируем значения
    # - Базовые (популярные) - для быстрого выбора
    # - Все (полный список) - для точного поиска
    
    return {
        'basic_colors': ['синий', 'красный', 'зеленый'],
        'colors': ['синий', 'синий с отливом', 'темно-синий', ...]
    }
```

### Поиск по диапазонам

Для числовых параметров (размеры) используется поиск по диапазонам:

```python
if params.get('size_min'):
    conditions.append("size_min >= %s")
    values.append(params['size_min'])

if params.get('size_max'):
    conditions.append("size_max <= %s")
    values.append(params['size_max'])
```

### Поиск в текстовых полях

Для текстовых полей используется `ILIKE` (нечувствительный к регистру поиск):

```python
if params.get('color'):
    conditions.append("color ILIKE %s")
    values.append(f"%{params['color']}%")
```

## 7. Управление подключениями

### Жизненный цикл подключения

```
1. Создание: conn = psycopg2.connect(**DB_CONFIG)
2. Создание курсора: cursor = conn.cursor()
3. Выполнение запроса: cursor.execute(query, values)
4. Получение результатов: results = cursor.fetchall()
5. Закрытие курсора: cursor.close()
6. Закрытие подключения: conn.close()
```

**Важно:** Всегда закрывайте курсор и подключение после использования!

### Обработка ошибок

```python
try:
    conn = self.get_connection()
    cursor = conn.cursor()
    cursor.execute(query, values)
    results = cursor.fetchall()
except psycopg2.Error as e:
    print(f"Ошибка БД: {e}")
    raise
finally:
    if cursor:
        cursor.close()
    if conn:
        conn.close()
```

## 8. Проверка работы БД

### Текущее состояние

- **База данных:** `insects_db`
- **Пользователь:** `wedben`
- **Хост:** `localhost:5432`
- **Таблицы:** 11 таблиц
- **Данные:** 
  - Стрекозы: 54 записи
  - Жуки: 35 записей
  - Бабочки: 25 записей

### Тестирование подключения

```python
from database import Database

db = Database()
conn = db.get_connection()
print("✅ Подключение успешно!")
conn.close()
```

## 9. Запуск приложения

Приложение запускается командой:

```bash
python3 app.py
```

**Порт:** 5001 (изменен с 5000 из-за конфликта портов)

**URL:** http://localhost:5001

При запуске:
1. Flask создает экземпляр `Database()`
2. При первом запросе создается подключение к БД
3. Выполняются SQL запросы
4. Результаты возвращаются клиенту

## 10. Резюме

**Как работает подключение:**
1. Параметры из `.env` → `config.py` → `DB_CONFIG`
2. `Database` использует `DB_CONFIG` для подключения
3. Каждый запрос создает новое подключение через `get_connection()`
4. Используются параметризованные запросы для безопасности
5. Результаты возвращаются в виде словарей (RealDictCursor)

**Преимущества текущей архитектуры:**
- ✅ Простота реализации
- ✅ Безопасность (параметризованные запросы)
- ✅ Гибкость (легко изменить параметры подключения)
- ✅ Читаемость кода

**Возможные улучшения:**
- Использование пула соединений для повышения производительности
- Кэширование часто используемых запросов
- Логирование всех SQL запросов

